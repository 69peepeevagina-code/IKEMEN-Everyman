
import React, { useState } from 'react';
import { EditorLayout } from './components/EditorLayout';
import { GridEditor } from './components/GridEditor';
import { AIModal } from './components/AIModal';
import { GlobalSettings } from './components/GlobalSettings';
import { ScreenpackEditor } from './components/ScreenpackEditor';
import { MotifManager } from './components/MotifManager';
import { SelectDefData, CharacterDef, GridSettings, SystemDefData } from './types';
import { parseSelectDef, stringifySelectDef, parseSystemDef } from './services/parser';
import { openFilePicker, openDirectoryPicker, scanCharactersLoader, scanStagesLoader, getCharacterPortrait } from './services/fileSystem';
import { generateAutoItScript } from './services/autoitGenerator';
import { Copy, Check, FileCode } from 'lucide-react';
import { NotificationState } from './components/NotificationToast';

const DEFAULT_CONTENT = `; IKEMEN Go / MUGEN Select Definition
; Generated by Select Editor

[Characters]
kfm, stages/mountains.def, order=1
kfm720, stages/mountains.def, order=1
randomselect
blank
blank
KungFuMan, stages/temple.def, music=sound/kfm.mp3

[ExtraStages]
stages/stage0.def
stages/kfm.def

[Options]
arcade.maxmatches = 6,1,1,0,0,0,0,0,0,0
team.maxmatches = 4,1,1,0,0,0,0,0,0,0
musicvictory = sound/victory.mp3
`;

const DEFAULT_SYSTEM = `; Default System
[Select Info]
rows = 5
columns = 10
pos = 50,200
cell.size = 27,27
cell.spacing = 2,2
wrapping = 1
showemptycursor = 0
p1.cursor.startcell = 0,0
p2.cursor.startcell = 0,9
portrait.scale = 1,1
`;

const App: React.FC = () => {
  const [data, setData] = useState<SelectDefData>(() => parseSelectDef(DEFAULT_CONTENT));
  const [systemData, setSystemData] = useState<SystemDefData>(() => parseSystemDef(DEFAULT_SYSTEM));
  
  const [activeTab, setActiveTab] = useState('characters');
  const [gridSettings, setGridSettings] = useState<GridSettings>({ rows: 4, cols: 5 });
  const [isAIModalOpen, setIsAIModalOpen] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  
  // Notification State
  const [notification, setNotification] = useState<NotificationState | null>(null);

  const notify = (message: string, type: 'success' | 'error' | 'info' = 'info') => {
    setNotification({ message, type });
  };
  
  // Scanned lists
  const [scannedChars, setScannedChars] = useState<string[]>([]);
  const [scannedStages, setScannedStages] = useState<string[]>([]);
  
  // Directory Handles
  const [charsDirHandle, setCharsDirHandle] = useState<any>(null);
  const [stagesDirHandle, setStagesDirHandle] = useState<any>(null);
  const [dataDirHandle, setDataDirHandle] = useState<any>(null);
  const [rootDirHandle, setRootDirHandle] = useState<any>(null); // For saving config.json

  // Sync characters to main data structure
  const setCharacters = (chars: CharacterDef[]) => {
    setData(prev => ({ ...prev, characters: chars }));
  };

  const handleExport = () => {
    try {
        const content = stringifySelectDef(data);
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'select.def';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        notify("File exported successfully!", "success");
    } catch (e) {
        notify("Failed to export file.", "error");
    }
  };

  const handleCopyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
    setCopySuccess(true);
    setTimeout(() => setCopySuccess(false), 2000);
    notify("Copied to clipboard.", "info");
  };
  
  const handleOpenFile = async () => {
      try {
        const result = await openFilePicker({'text/plain': ['.def']});
        if (result) {
            try {
                if (result.name.toLowerCase().includes('system')) {
                    const sysData = parseSystemDef(result.content);
                    setSystemData(sysData);
                    setGridSettings({
                        rows: sysData.selectInfo.rows,
                        cols: sysData.selectInfo.columns
                    });
                    setActiveTab('screenpack');
                    notify(`Loaded system configuration from ${result.name}`, "success");
                } else {
                    const newData = parseSelectDef(result.content);
                    setData(newData);
                    notify(`Loaded select definition from ${result.name}`, "success");
                }
            } catch (e: any) {
                console.error(e);
                notify("Failed to parse file content. Ensure it is a valid select.def or system.def.", "error");
            }
        }
      } catch (e: any) {
          notify(e.message || "Failed to open file.", "error");
      }
  };
  
  // Handlers for fetching handles if missing
  const requestDir = async (type: 'chars'|'stages'|'data'|'root') => {
      try {
          const dir = await openDirectoryPicker();
          if (dir) {
              if (type === 'chars') { setCharsDirHandle(dir); handleScanChars(dir); }
              if (type === 'stages') { setStagesDirHandle(dir); handleScanStages(dir); }
              if (type === 'data') setDataDirHandle(dir);
              if (type === 'root') setRootDirHandle(dir); // Usually parent of chars/data
              return dir;
          }
      } catch (e) {
          console.error(e);
      }
      return null;
  }
  
  const handleScanChars = async (handle?: any) => {
      try {
        const dir = handle || await requestDir('chars');
        if (dir) {
            const files = await scanCharactersLoader(dir);
            setScannedChars(files);
            if (!handle) notify(`Scan complete! Found ${files.length} characters.`, "success");
            
            const newCharState = [...data.characters];
            for (let i = 0; i < newCharState.length; i++) {
                const char = newCharState[i];
                if (char.name === 'randomselect' || char.name === 'blank') continue;
                
                // Find matching def file
                const match = files.find(f => f.includes(`${char.name}.def`));
                if (match && !char.portraitUrl) {
                     getCharacterPortrait(char.name, match, dir).then(url => {
                         if (url) {
                             // Update state asynchronously
                             setData(prev => ({
                                 ...prev,
                                 characters: prev.characters.map(c => c.id === char.id ? {...c, portraitUrl: url} : c)
                             }));
                         }
                     });
                }
            }
        }
      } catch (e: any) {
          notify(e.message || "Failed to scan characters directory.", "error");
      }
  };
  
  const handleScanStages = async (handle?: any) => {
      try {
        const dir = handle || await requestDir('stages');
        if (dir) {
            const files = await scanStagesLoader(dir);
            setScannedStages(files);
            if (!handle) notify(`Scan complete! Found ${files.length} stages.`, "success");
        }
      } catch (e: any) {
          notify(e.message || "Failed to scan stages directory.", "error");
      }
  };

  const generatedCode = stringifySelectDef(data);
  const autoItCode = generateAutoItScript(data);

  return (
    <EditorLayout 
      onExport={handleExport}
      onOpen={handleOpenFile}
      onScanChars={() => handleScanChars()}
      onScanStages={() => handleScanStages()}
      activeTab={activeTab}
      setActiveTab={setActiveTab}
      onAIModalOpen={() => setIsAIModalOpen(true)}
      notification={notification}
      onCloseNotification={() => setNotification(null)}
    >
      {activeTab === 'characters' && (
        <GridEditor 
          characters={data.characters}
          setCharacters={setCharacters}
          gridSettings={gridSettings}
          setGridSettings={setGridSettings}
          availableFiles={scannedChars}
          availableStages={scannedStages}
        />
      )}

      {activeTab === 'screenpack' && (
          <ScreenpackEditor 
              config={systemData.selectInfo}
              setConfig={(c) => {
                  setSystemData({...systemData, selectInfo: c});
                  setGridSettings({rows: c.rows, cols: c.columns});
              }}
          />
      )}

      {activeTab === 'motifs' && (
          <MotifManager 
            dataDirHandle={dataDirHandle}
            onRequestDir={() => requestDir('data')}
            rootDirHandle={rootDirHandle}
          />
      )}

      {activeTab === 'stages' && (
        <div className="flex h-full flex-col gap-4 rounded-lg border border-zinc-800 bg-black p-6">
          <div className="flex items-center justify-between">
             <h2 className="text-xl font-bold text-zinc-100">[ExtraStages]</h2>
             <span className="text-xs text-zinc-500">
                {scannedStages.length > 0 && `(Scanned ${scannedStages.length} stages available)`}
             </span>
          </div>
          <p className="text-sm text-zinc-400">List stages here that aren't assigned to any character but should appear in stage select.</p>
          <div className="flex-1 relative">
             <textarea
                className="absolute inset-0 w-full h-full resize-none rounded bg-zinc-950 p-4 font-mono text-sm text-zinc-300 outline-none ring-1 ring-zinc-800 focus:ring-white"
                value={data.extraStages.join('\n')}
                onChange={(e) => setData({ ...data, extraStages: e.target.value.split('\n') })}
                placeholder="stages/my_stage.def"
            />
          </div>
        </div>
      )}

      {activeTab === 'settings' && (
          <GlobalSettings 
              options={data.options}
              setOptions={(opt) => setData({...data, options: opt})}
          />
      )}

      {activeTab === 'code' && (
        <div className="relative h-full flex flex-col gap-4">
           <div className="absolute top-4 right-4 z-10">
              <button 
                onClick={() => handleCopyToClipboard(generatedCode)}
                className="flex items-center gap-2 rounded bg-zinc-800 px-3 py-1.5 text-xs font-medium text-zinc-300 hover:bg-zinc-700 hover:text-white"
              >
                {copySuccess ? <Check className="h-3 w-3 text-white" /> : <Copy className="h-3 w-3" />}
                {copySuccess ? 'Copied' : 'Copy Raw'}
              </button>
           </div>
          <div className="flex-1 overflow-auto rounded-lg border border-zinc-800 bg-black p-6">
            <pre className="font-mono text-xs leading-relaxed text-zinc-100">
              {generatedCode}
            </pre>
          </div>
        </div>
      )}

      {activeTab === 'autoit' && (
        <div className="relative h-full flex flex-col gap-4">
           <div className="absolute top-4 right-4 z-10">
              <button 
                onClick={() => handleCopyToClipboard(autoItCode)}
                className="flex items-center gap-2 rounded bg-zinc-900 border border-zinc-700 px-3 py-1.5 text-xs font-medium text-zinc-300 hover:bg-zinc-800 hover:text-white"
              >
                {copySuccess ? <Check className="h-3 w-3 text-white" /> : <FileCode className="h-3 w-3" />}
                {copySuccess ? 'Copied' : 'Copy .au3 Script'}
              </button>
           </div>
           <div className="flex flex-col gap-2 p-4 bg-zinc-900 rounded-lg border border-zinc-800">
               <h2 className="text-lg font-bold text-zinc-400 flex items-center gap-2">
                   <FileCode className="h-5 w-5" /> AutoIt Source Generator
               </h2>
               <p className="text-sm text-zinc-400">
                   This generated script includes a <b>Tabbed Interface</b> and <b>List View</b> to easily manage characters natively in Windows.
               </p>
           </div>
          <div className="flex-1 overflow-auto rounded-lg border border-zinc-800 bg-black p-6">
            <pre className="font-mono text-xs leading-relaxed text-zinc-100/80">
              {autoItCode}
            </pre>
          </div>
        </div>
      )}

      <AIModal 
        isOpen={isAIModalOpen}
        onClose={() => setIsAIModalOpen(false)}
        onApply={(newChars) => {
          setData(prev => ({...prev, characters: [...prev.characters, ...newChars]}));
          notify(`Added ${newChars.length} AI generated characters!`, "success");
        }}
      />
    </EditorLayout>
  );
};

export default App;
