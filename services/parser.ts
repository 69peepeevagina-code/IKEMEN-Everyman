
import { SelectDefData, CharacterDef, SelectOptions, SystemDefData, ScreenpackConfig } from '../types';

export const generateId = () => Math.random().toString(36).substr(2, 9);

export const parseSelectDef = (content: string): SelectDefData => {
  const lines = content.split(/\r?\n/);
  const characters: CharacterDef[] = [];
  const extraStages: string[] = [];
  const options: SelectOptions = {
    arcadeStartBattles: 0,
    arcadeMaxBattles: 0,
    teamStartBattles: 0,
    teamMaxBattles: 0,
    survivalMaxBattles: 0,
  };

  let currentSection = '';

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith(';')) continue;

    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
      currentSection = trimmed.slice(1, -1).toLowerCase();
      continue;
    }

    if (currentSection === 'characters') {
      let workLine = trimmed;
      // Extract unlock param first if it exists
      let unlockVal = '';
      const unlockIndex = workLine.toLowerCase().lastIndexOf('unlock=');
      if (unlockIndex !== -1) {
        unlockVal = workLine.substring(unlockIndex + 7).trim();
        workLine = workLine.substring(0, unlockIndex).trim();
        if (workLine.endsWith(',')) workLine = workLine.slice(0, -1);
      }

      const parts = workLine.split(',').map(p => p.trim());
      const name = parts[0];
      
      const charDef: CharacterDef = { id: generateId(), name };
      if (unlockVal) charDef.unlock = unlockVal;

      for (let i = 1; i < parts.length; i++) {
        const part = parts[i];
        const lowerPart = part.toLowerCase();
        
        if (lowerPart.startsWith('stage=')) {
          charDef.stage = part.split('=')[1];
        } else if (lowerPart.startsWith('music=')) {
          charDef.music = part.split('=')[1];
        } else if (lowerPart.startsWith('order=')) {
          charDef.order = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('include=')) {
           charDef.includeStage = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('exclude=')) {
           charDef.exclude = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('bonus=')) {
           charDef.bonus = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('ai=')) {
           charDef.aiLevel = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('localcoord=')) {
           charDef.localcoord = parseInt(part.split('=')[1], 10);
        } else if (lowerPart.startsWith('pal=')) {
           charDef.palettes = part.split('=')[1];
        } else if (lowerPart.startsWith('vsscreen=')) {
           charDef.vsscreen = parseInt(part.split('=')[1], 10);
        } else if (!charDef.stage && !part.includes('=')) {
          charDef.stage = part;
        } else if (part) {
           charDef.paramStr = (charDef.paramStr ? charDef.paramStr + ', ' : '') + part;
        }
      }
      characters.push(charDef);
    } else if (currentSection === 'extrastages') {
      extraStages.push(trimmed);
    } else if (currentSection === 'options') {
      const [key, val] = trimmed.split('=').map(s => s.trim());
      if (key && val) {
        if (key.toLowerCase() === 'musicvictory') {
            options.musicVictory = val;
        } else {
            if (key.includes('arcadestart')) options.arcadeStartBattles = parseInt(val, 10);
            (options as any)[key] = isNaN(Number(val)) ? val : Number(val);
        }
      }
    }
  }

  return { characters, extraStages, options, rawContent: content };
};

export const stringifySelectDef = (data: SelectDefData): string => {
  let output = '; Generated by IKEMEN Go Select Editor\n\n';

  // Characters
  output += '[Characters]\n';
  data.characters.forEach(char => {
    let line = `${char.name}`;
    if (char.stage) line += `, stage=${char.stage}`;
    if (char.music) line += `, music=${char.music}`;
    if (char.order !== undefined) line += `, order=${char.order}`;
    if (char.includeStage !== undefined) line += `, include=${char.includeStage}`;
    if (char.exclude !== undefined) line += `, exclude=${char.exclude}`;
    if (char.bonus !== undefined) line += `, bonus=${char.bonus}`;
    if (char.aiLevel !== undefined) line += `, ai=${char.aiLevel}`;
    if (char.localcoord !== undefined) line += `, localcoord=${char.localcoord}`;
    if (char.palettes) line += `, pal=${char.palettes}`;
    if (char.vsscreen !== undefined) line += `, vsscreen=${char.vsscreen}`;
    if (char.paramStr) line += `, ${char.paramStr}`;
    if (char.unlock) line += `, unlock=${char.unlock}`;
    
    output += `${line}\n`;
  });

  // ExtraStages
  output += '\n[ExtraStages]\n';
  data.extraStages.forEach(stage => {
    output += `${stage}\n`;
  });

  // Options
  output += '\n[Options]\n';
  Object.entries(data.options).forEach(([key, val]) => {
     if (key === 'musicVictory') {
         if (val) output += `musicvictory = ${val}\n`;
     } else {
         output += `${key} = ${val}\n`;
     }
  });

  return output;
};

// --- System.def Parsing ---

const DEFAULT_SCREENPACK: ScreenpackConfig = {
    rows: 10,
    columns: 10,
    pos: [10, 10],
    cellSize: [27, 27],
    cellSpacing: [2, 2],
    wrapping: 1,
    showEmptyCursor: 0,
    p1CursorStartCell: [0, 0],
    p2CursorStartCell: [0, 9],
    portraitScale: [1, 1],
};

export const parseSystemDef = (content: string): SystemDefData => {
    const lines = content.split(/\r?\n/);
    let currentSection = '';
    const config = { ...DEFAULT_SCREENPACK };

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith(';')) continue;

        if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
            currentSection = trimmed.slice(1, -1).toLowerCase().replace(/\s/g, ''); // normalize 'select info' to 'selectinfo'
            continue;
        }

        if (currentSection === 'selectinfo') {
            const [keyPart, valPart] = trimmed.split('=').map(s => s.trim().toLowerCase());
            if (!keyPart || !valPart) continue;

            const vals = valPart.split(',').map(v => parseFloat(v));

            if (keyPart === 'rows') config.rows = vals[0];
            else if (keyPart === 'columns') config.columns = vals[0];
            else if (keyPart === 'pos') config.pos = [vals[0], vals[1] || 0];
            else if (keyPart === 'cell.size') config.cellSize = [vals[0], vals[1] || vals[0]];
            else if (keyPart === 'cell.spacing') config.cellSpacing = [vals[0], vals[1] || 0];
            else if (keyPart === 'wrapping') config.wrapping = vals[0];
            else if (keyPart === 'showemptycursor') config.showEmptyCursor = vals[0];
            else if (keyPart === 'p1.cursor.startcell') config.p1CursorStartCell = [vals[0], vals[1] || 0];
            else if (keyPart === 'p2.cursor.startcell') config.p2CursorStartCell = [vals[0], vals[1] || 0];
            else if (keyPart === 'portrait.scale') config.portraitScale = [vals[0], vals[1] || vals[0]];
        }
    }

    return { selectInfo: config, rawContent: content };
};

export const stringifySystemDef = (data: SystemDefData): string => {
    const block = `[Select Info]
rows = ${data.selectInfo.rows}
columns = ${data.selectInfo.columns}
pos = ${data.selectInfo.pos[0]},${data.selectInfo.pos[1]}
cell.size = ${data.selectInfo.cellSize[0]},${data.selectInfo.cellSize[1]}
cell.spacing = ${data.selectInfo.cellSpacing[0]},${data.selectInfo.cellSpacing[1]}
wrapping = ${data.selectInfo.wrapping}
showemptycursor = ${data.selectInfo.showEmptyCursor}
p1.cursor.startcell = ${data.selectInfo.p1CursorStartCell[0]},${data.selectInfo.p1CursorStartCell[1]}
p2.cursor.startcell = ${data.selectInfo.p2CursorStartCell[0]},${data.selectInfo.p2CursorStartCell[1]}
portrait.scale = ${data.selectInfo.portraitScale[0]},${data.selectInfo.portraitScale[1]}
`;

    if (data.rawContent) {
        const regex = /\[Select Info\][\s\S]*?(?=\r?\n\[|$)/i;
        if (regex.test(data.rawContent)) {
            return data.rawContent.replace(regex, block.trim());
        } else {
            return data.rawContent + '\n\n' + block;
        }
    }

    return "; Generated System.def Segment\n" + block;
};
